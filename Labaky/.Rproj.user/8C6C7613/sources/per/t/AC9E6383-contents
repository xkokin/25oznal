---
title: "Labak 1.1"
author: "xkokin"
output: html_notebook
---

library(tidyverse)


# load data
players <- read.csv("./players_22.csv")

glimpse(players)

# task 2
# rows and colomns
n_rows <- nrow(players)
n_cols <- ncol(players)

c_names <- colnames(players)
c_names

is_labeled <- !is.null(c_names)
print(paste("is labeled: ", is_labeled))

# sapply applies selected function to each element, in this case - to each column in players 
columns_types <- sapply(players, class)
is_homogeneous <- length(unique(columns_types)) == 1
print(paste("is homogeneous: ", is_homogeneous))

# task 3
# %>% is a pipe operator, pass output from one function to another
col_type_counts <- sapply(players, class) %>% table()
print(col_type_counts)

# task 4
# complete.cases checks if column has a NA, sum then counts up how many columns with NA there are 
num_complete_records <- sum(complete.cases(players))
num_complete_records

# task 5
num_duplicate_rows <- sum(duplicated(players))

# Check for duplicate columns
# t is a transpose function, swaps rows and cols
num_duplicate_cols <- sum(duplicated(t(players)))

# show output in a list format
list(num_duplicate_rows = num_duplicate_rows, num_duplicate_cols = num_duplicate_cols)

# task 6
# select only numeric columns
numeric_data <- players[, sapply(players, is.numeric)]  

# get the min and max for each numeric column
numeric_ranges <- data.frame(
  min = sapply(numeric_data, min, na.rm = TRUE),
  max = sapply(numeric_data, max, na.rm = TRUE)
)

print(numeric_ranges)

# select only character (categorical) columns
categorical_data <- players[, sapply(players, is.character)]

# count unique values in each categorical column
categorical_values <- sapply(categorical_data, function(col) length(unique(col)))

# convert to dataframe for better readability
categorical_values <- data.frame(column = names(categorical_values), unique_count = categorical_values)

print(categorical_values)

list(numeric_ranges = numeric_ranges, categorical_values = categorical_values)

# task 7

glimpse(players)
# first few columns likely contain player identification
# latter columns contain performance metrics
# some columns may be redundant (like player_id appearing multiple times)
# could be re-arranged by placing key identifiers first, then by performance metrics


# tsk8

best_player <- players[which.max(players$overall),]
# find based on player's overall
best_player[c("short_name", "club_name", "overall", "wage_eur", "player_positions")]

# task 9 

# get top 100 players by overall
top_100 <- players %>%
  arrange(desc(overall)) %>%
  head(100)

# cCount left- and right-footed players in the top 100
left_right_footed <- top_100 %>%
  count(preferred_foot              )

# add proportion column
# n is property created by count
left_right_footed <- left_right_footed %>%
  mutate(proportion = n / sum(n))

left_right_footed

unique(players$preferred_foot)

# task 10 
# average overall rating for left- and right-footed players
left_vs_right_avg <- players %>%
  group_by(preferred_foot) %>%
  summarise(avg_overall = mean(overall))

left_vs_right_avg

# task 11

youngest_left <- players %>%
  filter(preferred_foot == "Left" & overall > 80) %>%
  arrange(age) %>%
  slice(1)

youngest_left[c("short_name", "age", "overall")]

# task 12

top_potential_left <- players %>%
  filter(preferred_foot == "Left", age < 35) %>%
  arrange(desc(potential)) %>%
  head(5)

top_potential_left[c("short_name", "age", "overall", "potential", "value_eur")]

# task 13

# best left-footed dribbler
best_dribbler <- players %>%
  filter(preferred_foot == "Left") %>%
  arrange(desc(dribbling)) %>%
  slice(1)

best_dribbler[c("short_name", "age", "dribbling")]

# number of left-footed players with shooting â‰¥ 85
left_high_shooters <- players %>%
  filter(preferred_foot == "Left", shooting >= 85) %>%
  count()

left_high_shooters

# best left-footed free kick taker
best_freekick_taker <- players %>%
  filter(preferred_foot == "Left") %>%
  arrange(desc(skill_fk_accuracy)) %>%
  slice(1)

best_freekick_taker[c("short_name", "skill_fk_accuracy")]

